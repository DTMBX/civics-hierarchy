import { Section, Document, Jurisdiction, VerificationStatus } from './types'
import { createAuditLog } from './compliance'

export type CitationFormat = 
  | 'bluebook' 
  | 'alwd' 
  | 'apa' 
  | 'mla' 
  | 'chicago' 
  | 'plain' 
  | 'court-filing'
  | 'bibtex'
  | 'json'

export type ExportFormat = 
  | 'txt' 
  | 'md' 
  | 'pdf' 
  | 'json' 
  | 'csv' 
  | 'docx' 
  | 'html'
  | 'rtf'
  | 'bibtex'

export interface CitationMetadata {
  section: Section
  document: Document
  jurisdiction: Jurisdiction
  retrievalDate: string
  userId: string
  exportDate: string
  verificationStatus: VerificationStatus
  lastVerified?: string
  sourceUrl?: string
  auditTrailId?: string
}

export interface ExportOptions {
  format: ExportFormat
  citationStyle: CitationFormat
  includeFullText: boolean
  includeMetadata: boolean
  includeDisclaimers: boolean
  includeAuditTrail: boolean
  includeVerificationInfo: boolean
  watermark?: string
  pageNumbers?: boolean
  timestamp?: boolean
}

export interface CourtDefensibleExport {
  citation: string
  fullText?: string
  metadata: {
    documentTitle: string
    documentType: string
    authorityLevel: string
    jurisdiction: string
    sectionReference: string
    canonicalCitation: string
    officialSourceUrl: string
    verificationStatus: VerificationStatus
    lastVerifiedDate: string
    retrievedDate: string
    exportedDate: string
    exportedBy: string
    auditTrailId: string
  }
  disclaimers: string[]
  verificationChain: {
    step: string
    verified: boolean
    timestamp: string
    verifiedBy?: string
  }[]
  legalNotice: string
}

const COURT_FILING_DISCLAIMER = `
IMPORTANT NOTICE FOR COURT FILINGS:
This document was generated by Civics Stack, an educational legal reference platform. 
While this platform maintains strict verification standards and audit trails, courts require 
citations to official government publications, not secondary sources.

FOR COURT FILINGS: Cite directly to official reporters, statutory compilations, or 
government publications. Use this export only as a research aid to locate the official source.

This export is provided for educational and research purposes only and does not constitute 
legal advice. Consult with a licensed attorney for legal advice specific to your situation.
`

const VERIFICATION_STANDARDS_NOTE = `
VERIFICATION STANDARDS:
All information in this export has been verified according to the following standards:
- Source citations traced to official government publications
- Verification status indicated for each document
- Audit trail maintained for all changes and access
- Regular verification cycles (90-day maximum intervals)
- Immutable timestamp records for all exports

Users remain responsible for independently verifying information with official sources 
before relying on it for legal, civic, or personal purposes.
`

export function generateBluebookCitation(metadata: CitationMetadata): string {
  const { section, document, jurisdiction } = metadata
  
  if (document.type === 'constitution') {
    if (jurisdiction.type === 'federal') {
      return formatUSConstitutionBluebook(section)
    } else {
      return formatStateConstitutionBluebook(section, jurisdiction)
    }
  }
  
  if (document.type === 'statute') {
    return formatStatuteBluebook(section, document, jurisdiction)
  }
  
  if (document.type === 'treaty') {
    return formatTreatyBluebook(section, document)
  }
  
  if (document.type === 'ordinance') {
    return formatOrdinanceBluebook(section, document, jurisdiction)
  }
  
  return section.canonicalCitation
}

function formatUSConstitutionBluebook(section: Section): string {
  return section.canonicalCitation
}

function formatStateConstitutionBluebook(section: Section, jurisdiction: Jurisdiction): string {
  const abbrev = jurisdiction.abbreviation || jurisdiction.name
  return section.canonicalCitation.replace(/^.*Const\./, `${abbrev} Const.`)
}

function formatStatuteBluebook(section: Section, document: Document, jurisdiction: Jurisdiction): string {
  return section.canonicalCitation
}

function formatTreatyBluebook(section: Section, document: Document): string {
  return section.canonicalCitation
}

function formatOrdinanceBluebook(section: Section, document: Document, jurisdiction: Jurisdiction): string {
  const localName = jurisdiction.name
  return `${localName} ${section.canonicalCitation}`
}

export function generateALWDCitation(metadata: CitationMetadata): string {
  const { section, document, jurisdiction } = metadata
  
  if (document.type === 'constitution') {
    if (jurisdiction.type === 'federal') {
      return section.canonicalCitation
    } else {
      const abbrev = jurisdiction.abbreviation || jurisdiction.name
      return section.canonicalCitation.replace(/^.*Const\./, `${abbrev} Const.`)
    }
  }
  
  return section.canonicalCitation
}

export function generateAPACitation(metadata: CitationMetadata): string {
  const { section, document, jurisdiction, retrievalDate } = metadata
  const year = document.effectiveDate ? new Date(document.effectiveDate).getFullYear() : 'n.d.'
  
  if (document.type === 'constitution') {
    return `${document.title}. (${year}). ${section.title}, ${section.canonicalCitation}. Retrieved ${retrievalDate}`
  }
  
  return `${document.title}. (${year}). ${section.canonicalCitation}. Retrieved ${retrievalDate} from ${document.sourceUrl || 'official government source'}`
}

export function generateMLACitation(metadata: CitationMetadata): string {
  const { section, document, jurisdiction, retrievalDate } = metadata
  
  if (document.type === 'constitution') {
    return `${document.title}. ${section.title}. ${section.canonicalCitation}. Web. ${retrievalDate}.`
  }
  
  return `${document.title}. ${section.canonicalCitation}. ${jurisdiction.name}, ${retrievalDate}. Web.`
}

export function generateChicagoCitation(metadata: CitationMetadata): string {
  const { section, document, jurisdiction, retrievalDate } = metadata
  
  if (document.type === 'constitution') {
    return `${jurisdiction.name}. ${document.title}, ${section.canonicalCitation}. Accessed ${retrievalDate}.`
  }
  
  return `${jurisdiction.name}. ${document.title}. ${section.canonicalCitation}. Accessed ${retrievalDate}.`
}

export function generatePlainCitation(metadata: CitationMetadata): string {
  const { section, document, jurisdiction } = metadata
  return `${document.title}, ${section.title} (${section.canonicalCitation})`
}

export function generateCourtFilingCitation(metadata: CitationMetadata): string {
  const { section, document, jurisdiction, lastVerified } = metadata
  const verifiedNote = lastVerified ? ` Last verified: ${new Date(lastVerified).toLocaleDateString()}.` : ''
  
  return `${document.title}, ${section.canonicalCitation}. Official source: ${document.sourceUrl || 'government publication'}.${verifiedNote} [Note: For court filings, cite directly to official government publications. This reference is provided for research purposes only.]`
}

export function generateBibTeX(metadata: CitationMetadata): string {
  const { section, document, jurisdiction, retrievalDate } = metadata
  const year = document.effectiveDate ? new Date(document.effectiveDate).getFullYear() : new Date().getFullYear()
  const key = `${jurisdiction.abbreviation || jurisdiction.id}_${document.id}_${section.number}`.replace(/[^a-zA-Z0-9_]/g, '_')
  
  return `@misc{${key},
  title = {${document.title}},
  section = {${section.title}},
  citation = {${section.canonicalCitation}},
  jurisdiction = {${jurisdiction.name}},
  year = {${year}},
  howpublished = {\\url{${document.sourceUrl || 'official government source'}}},
  note = {Retrieved ${retrievalDate}. Educational reference only.}
}`
}

export function generateCitation(
  metadata: CitationMetadata,
  format: CitationFormat
): string {
  switch (format) {
    case 'bluebook':
      return generateBluebookCitation(metadata)
    case 'alwd':
      return generateALWDCitation(metadata)
    case 'apa':
      return generateAPACitation(metadata)
    case 'mla':
      return generateMLACitation(metadata)
    case 'chicago':
      return generateChicagoCitation(metadata)
    case 'plain':
      return generatePlainCitation(metadata)
    case 'court-filing':
      return generateCourtFilingCitation(metadata)
    case 'bibtex':
      return generateBibTeX(metadata)
    case 'json':
      return JSON.stringify({
        citation: metadata.section.canonicalCitation,
        document: metadata.document.title,
        section: metadata.section.title,
        jurisdiction: metadata.jurisdiction.name,
        retrievalDate: metadata.retrievalDate,
      }, null, 2)
    default:
      return generateBluebookCitation(metadata)
  }
}

export async function generateCourtDefensibleExport(
  metadata: CitationMetadata,
  options: ExportOptions
): Promise<CourtDefensibleExport> {
  const citation = generateCitation(metadata, options.citationStyle)
  
  const auditLogEntry = await createAuditLog({
    userId: metadata.userId,
    userRole: 'reader',
    action: 'export',
    entityType: 'citation',
    entityId: metadata.section.id,
    metadata: {
      format: options.format,
      citationStyle: options.citationStyle,
      documentId: metadata.document.id,
      jurisdictionId: metadata.jurisdiction.id,
    },
  })
  
  const disclaimers = [
    'NOT LEGAL ADVICE: This export is for educational and informational purposes only.',
    'NO ATTORNEY-CLIENT RELATIONSHIP: Use of this export does not create an attorney-client relationship.',
    'VERIFY ALL SOURCES: Users are responsible for independently verifying all information with official government sources.',
    'COURT FILINGS: For court filings, cite directly to official government publications, not this educational platform.',
  ]
  
  const verificationChain = [
    {
      step: 'Source Document Verification',
      verified: metadata.document.verificationStatus === 'official' || metadata.document.verificationStatus === 'verified',
      timestamp: metadata.lastVerified || metadata.document.lastChecked || 'unknown',
      verifiedBy: metadata.document.verificationStatus === 'official' ? 'Official Source' : 'Curator',
    },
    {
      step: 'Citation Accuracy Check',
      verified: !!metadata.section.canonicalCitation,
      timestamp: metadata.exportDate,
    },
    {
      step: 'Audit Trail Generation',
      verified: true,
      timestamp: auditLogEntry.timestamp,
    },
  ]
  
  return {
    citation,
    fullText: options.includeFullText ? metadata.section.text : undefined,
    metadata: {
      documentTitle: metadata.document.title,
      documentType: metadata.document.type,
      authorityLevel: metadata.document.authorityLevel,
      jurisdiction: metadata.jurisdiction.name,
      sectionReference: `${metadata.section.title} (${metadata.section.number})`,
      canonicalCitation: metadata.section.canonicalCitation,
      officialSourceUrl: metadata.document.sourceUrl || 'Contact jurisdiction for official source',
      verificationStatus: metadata.document.verificationStatus,
      lastVerifiedDate: metadata.lastVerified || metadata.document.lastChecked || 'Not available',
      retrievedDate: metadata.retrievalDate,
      exportedDate: metadata.exportDate,
      exportedBy: metadata.userId,
      auditTrailId: auditLogEntry.id,
    },
    disclaimers: options.includeDisclaimers ? disclaimers : [],
    verificationChain: options.includeVerificationInfo ? verificationChain : [],
    legalNotice: COURT_FILING_DISCLAIMER,
  }
}

export function formatExportAsText(exportData: CourtDefensibleExport, options: ExportOptions): string {
  const lines: string[] = []
  
  lines.push('='.repeat(80))
  lines.push('CIVICS STACK LEGAL CITATION EXPORT')
  lines.push('Educational Reference Only - Not Legal Advice')
  lines.push('='.repeat(80))
  lines.push('')
  
  lines.push('CITATION:')
  lines.push(exportData.citation)
  lines.push('')
  
  if (options.includeMetadata) {
    lines.push('DOCUMENT METADATA:')
    lines.push(`  Document: ${exportData.metadata.documentTitle}`)
    lines.push(`  Type: ${exportData.metadata.documentType}`)
    lines.push(`  Authority Level: ${exportData.metadata.authorityLevel}`)
    lines.push(`  Jurisdiction: ${exportData.metadata.jurisdiction}`)
    lines.push(`  Section: ${exportData.metadata.sectionReference}`)
    lines.push(`  Canonical Citation: ${exportData.metadata.canonicalCitation}`)
    lines.push(`  Official Source: ${exportData.metadata.officialSourceUrl}`)
    lines.push(`  Verification Status: ${exportData.metadata.verificationStatus}`)
    lines.push(`  Last Verified: ${exportData.metadata.lastVerifiedDate}`)
    lines.push(`  Retrieved: ${exportData.metadata.retrievedDate}`)
    lines.push(`  Exported: ${exportData.metadata.exportedDate}`)
    lines.push(`  Exported By: ${exportData.metadata.exportedBy}`)
    if (options.includeAuditTrail) {
      lines.push(`  Audit Trail ID: ${exportData.metadata.auditTrailId}`)
    }
    lines.push('')
  }
  
  if (exportData.fullText && options.includeFullText) {
    lines.push('FULL TEXT:')
    lines.push('-'.repeat(80))
    lines.push(exportData.fullText)
    lines.push('-'.repeat(80))
    lines.push('')
  }
  
  if (options.includeVerificationInfo) {
    lines.push('VERIFICATION CHAIN:')
    exportData.verificationChain.forEach((step) => {
      lines.push(`  ✓ ${step.step}`)
      lines.push(`    Status: ${step.verified ? 'VERIFIED' : 'UNVERIFIED'}`)
      lines.push(`    Timestamp: ${step.timestamp}`)
      if (step.verifiedBy) {
        lines.push(`    Verified By: ${step.verifiedBy}`)
      }
    })
    lines.push('')
    lines.push(VERIFICATION_STANDARDS_NOTE)
    lines.push('')
  }
  
  if (options.includeDisclaimers) {
    lines.push('LEGAL DISCLAIMERS:')
    exportData.disclaimers.forEach((disclaimer, idx) => {
      lines.push(`  ${idx + 1}. ${disclaimer}`)
    })
    lines.push('')
    lines.push(exportData.legalNotice)
    lines.push('')
  }
  
  lines.push('='.repeat(80))
  lines.push('END OF EXPORT')
  lines.push('='.repeat(80))
  
  return lines.join('\n')
}

export function formatExportAsMarkdown(exportData: CourtDefensibleExport, options: ExportOptions): string {
  const lines: string[] = []
  
  lines.push('# Civics Stack Legal Citation Export')
  lines.push('')
  lines.push('**Educational Reference Only - Not Legal Advice**')
  lines.push('')
  lines.push('---')
  lines.push('')
  
  lines.push('## Citation')
  lines.push('')
  lines.push('```')
  lines.push(exportData.citation)
  lines.push('```')
  lines.push('')
  
  if (options.includeMetadata) {
    lines.push('## Document Metadata')
    lines.push('')
    lines.push(`- **Document:** ${exportData.metadata.documentTitle}`)
    lines.push(`- **Type:** ${exportData.metadata.documentType}`)
    lines.push(`- **Authority Level:** ${exportData.metadata.authorityLevel}`)
    lines.push(`- **Jurisdiction:** ${exportData.metadata.jurisdiction}`)
    lines.push(`- **Section:** ${exportData.metadata.sectionReference}`)
    lines.push(`- **Canonical Citation:** ${exportData.metadata.canonicalCitation}`)
    lines.push(`- **Official Source:** [${exportData.metadata.officialSourceUrl}](${exportData.metadata.officialSourceUrl})`)
    lines.push(`- **Verification Status:** ${exportData.metadata.verificationStatus}`)
    lines.push(`- **Last Verified:** ${exportData.metadata.lastVerifiedDate}`)
    lines.push(`- **Retrieved:** ${exportData.metadata.retrievedDate}`)
    lines.push(`- **Exported:** ${exportData.metadata.exportedDate}`)
    lines.push(`- **Exported By:** ${exportData.metadata.exportedBy}`)
    if (options.includeAuditTrail) {
      lines.push(`- **Audit Trail ID:** \`${exportData.metadata.auditTrailId}\``)
    }
    lines.push('')
  }
  
  if (exportData.fullText && options.includeFullText) {
    lines.push('## Full Text')
    lines.push('')
    lines.push('```')
    lines.push(exportData.fullText)
    lines.push('```')
    lines.push('')
  }
  
  if (options.includeVerificationInfo) {
    lines.push('## Verification Chain')
    lines.push('')
    exportData.verificationChain.forEach((step) => {
      lines.push(`### ${step.step}`)
      lines.push(`- **Status:** ${step.verified ? '✓ VERIFIED' : '✗ UNVERIFIED'}`)
      lines.push(`- **Timestamp:** ${step.timestamp}`)
      if (step.verifiedBy) {
        lines.push(`- **Verified By:** ${step.verifiedBy}`)
      }
      lines.push('')
    })
    lines.push('### Verification Standards')
    lines.push('')
    lines.push(VERIFICATION_STANDARDS_NOTE)
    lines.push('')
  }
  
  if (options.includeDisclaimers) {
    lines.push('## Legal Disclaimers')
    lines.push('')
    exportData.disclaimers.forEach((disclaimer, idx) => {
      lines.push(`${idx + 1}. **${disclaimer}**`)
    })
    lines.push('')
    lines.push('### Important Notice for Court Filings')
    lines.push('')
    lines.push(exportData.legalNotice)
    lines.push('')
  }
  
  lines.push('---')
  lines.push('')
  lines.push('*Generated by Civics Stack - Educational Legal Reference Platform*')
  lines.push('')
  
  return lines.join('\n')
}

export function formatExportAsHTML(exportData: CourtDefensibleExport, options: ExportOptions): string {
  let html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Civics Stack Citation Export</title>
  <style>
    body {
      font-family: 'Georgia', serif;
      max-width: 800px;
      margin: 40px auto;
      padding: 20px;
      line-height: 1.6;
      color: #333;
    }
    .header {
      text-align: center;
      border-bottom: 3px solid #333;
      padding-bottom: 20px;
      margin-bottom: 30px;
    }
    .header h1 {
      margin: 0;
      font-size: 24px;
    }
    .header .subtitle {
      color: #666;
      font-style: italic;
      margin-top: 10px;
    }
    .section {
      margin: 30px 0;
    }
    .section h2 {
      font-size: 18px;
      border-bottom: 2px solid #ddd;
      padding-bottom: 8px;
      margin-bottom: 15px;
    }
    .citation-box {
      background: #f5f5f5;
      border-left: 4px solid #333;
      padding: 15px;
      margin: 15px 0;
      font-family: 'Courier New', monospace;
    }
    .metadata-table {
      width: 100%;
      border-collapse: collapse;
    }
    .metadata-table td {
      padding: 8px;
      border-bottom: 1px solid #eee;
    }
    .metadata-table td:first-child {
      font-weight: bold;
      width: 200px;
      color: #555;
    }
    .full-text {
      background: #fafafa;
      border: 1px solid #ddd;
      padding: 20px;
      margin: 15px 0;
      white-space: pre-wrap;
      font-family: 'Georgia', serif;
    }
    .verification-step {
      background: #f0f8f0;
      border-left: 3px solid #28a745;
      padding: 10px 15px;
      margin: 10px 0;
    }
    .verification-step.unverified {
      background: #fff8f0;
      border-left-color: #ffc107;
    }
    .disclaimer {
      background: #fff3cd;
      border: 1px solid #ffc107;
      padding: 15px;
      margin: 10px 0;
      border-radius: 4px;
    }
    .legal-notice {
      background: #f8d7da;
      border: 2px solid #dc3545;
      padding: 20px;
      margin: 20px 0;
      border-radius: 4px;
    }
    .footer {
      text-align: center;
      border-top: 2px solid #ddd;
      padding-top: 20px;
      margin-top: 40px;
      color: #666;
      font-size: 14px;
    }
    @media print {
      body { margin: 0; padding: 20px; }
      .no-print { display: none; }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Civics Stack Legal Citation Export</h1>
    <div class="subtitle">Educational Reference Only - Not Legal Advice</div>
  </div>

  <div class="section">
    <h2>Citation</h2>
    <div class="citation-box">${escapeHtml(exportData.citation)}</div>
  </div>
`

  if (options.includeMetadata) {
    html += `
  <div class="section">
    <h2>Document Metadata</h2>
    <table class="metadata-table">
      <tr><td>Document</td><td>${escapeHtml(exportData.metadata.documentTitle)}</td></tr>
      <tr><td>Type</td><td>${escapeHtml(exportData.metadata.documentType)}</td></tr>
      <tr><td>Authority Level</td><td>${escapeHtml(exportData.metadata.authorityLevel)}</td></tr>
      <tr><td>Jurisdiction</td><td>${escapeHtml(exportData.metadata.jurisdiction)}</td></tr>
      <tr><td>Section</td><td>${escapeHtml(exportData.metadata.sectionReference)}</td></tr>
      <tr><td>Canonical Citation</td><td>${escapeHtml(exportData.metadata.canonicalCitation)}</td></tr>
      <tr><td>Official Source</td><td><a href="${escapeHtml(exportData.metadata.officialSourceUrl)}">${escapeHtml(exportData.metadata.officialSourceUrl)}</a></td></tr>
      <tr><td>Verification Status</td><td>${escapeHtml(exportData.metadata.verificationStatus)}</td></tr>
      <tr><td>Last Verified</td><td>${escapeHtml(exportData.metadata.lastVerifiedDate)}</td></tr>
      <tr><td>Retrieved</td><td>${escapeHtml(exportData.metadata.retrievedDate)}</td></tr>
      <tr><td>Exported</td><td>${escapeHtml(exportData.metadata.exportedDate)}</td></tr>
      <tr><td>Exported By</td><td>${escapeHtml(exportData.metadata.exportedBy)}</td></tr>
      ${options.includeAuditTrail ? `<tr><td>Audit Trail ID</td><td><code>${escapeHtml(exportData.metadata.auditTrailId)}</code></td></tr>` : ''}
    </table>
  </div>
`
  }

  if (exportData.fullText && options.includeFullText) {
    html += `
  <div class="section">
    <h2>Full Text</h2>
    <div class="full-text">${escapeHtml(exportData.fullText)}</div>
  </div>
`
  }

  if (options.includeVerificationInfo) {
    html += `
  <div class="section">
    <h2>Verification Chain</h2>
`
    exportData.verificationChain.forEach((step) => {
      const className = step.verified ? 'verification-step' : 'verification-step unverified'
      html += `
    <div class="${className}">
      <strong>${escapeHtml(step.step)}</strong><br>
      Status: ${step.verified ? '✓ VERIFIED' : '✗ UNVERIFIED'}<br>
      Timestamp: ${escapeHtml(step.timestamp)}
      ${step.verifiedBy ? `<br>Verified By: ${escapeHtml(step.verifiedBy)}` : ''}
    </div>
`
    })
    html += `
    <div class="disclaimer">
      <pre style="white-space: pre-wrap; margin: 0; font-family: inherit;">${escapeHtml(VERIFICATION_STANDARDS_NOTE)}</pre>
    </div>
  </div>
`
  }

  if (options.includeDisclaimers) {
    html += `
  <div class="section">
    <h2>Legal Disclaimers</h2>
`
    exportData.disclaimers.forEach((disclaimer, idx) => {
      html += `    <div class="disclaimer"><strong>${idx + 1}.</strong> ${escapeHtml(disclaimer)}</div>\n`
    })
    html += `
    <div class="legal-notice">
      <h3 style="margin-top: 0;">Important Notice for Court Filings</h3>
      <pre style="white-space: pre-wrap; margin: 0; font-family: inherit;">${escapeHtml(exportData.legalNotice)}</pre>
    </div>
  </div>
`
  }

  html += `
  <div class="footer">
    Generated by Civics Stack - Educational Legal Reference Platform
  </div>
</body>
</html>
`

  return html
}

export function formatExportAsJSON(exportData: CourtDefensibleExport): string {
  return JSON.stringify(exportData, null, 2)
}

export function formatExportAsCSV(exportData: CourtDefensibleExport): string {
  const rows = [
    ['Field', 'Value'],
    ['Citation', exportData.citation],
    ['Document Title', exportData.metadata.documentTitle],
    ['Document Type', exportData.metadata.documentType],
    ['Authority Level', exportData.metadata.authorityLevel],
    ['Jurisdiction', exportData.metadata.jurisdiction],
    ['Section Reference', exportData.metadata.sectionReference],
    ['Canonical Citation', exportData.metadata.canonicalCitation],
    ['Official Source URL', exportData.metadata.officialSourceUrl],
    ['Verification Status', exportData.metadata.verificationStatus],
    ['Last Verified Date', exportData.metadata.lastVerifiedDate],
    ['Retrieved Date', exportData.metadata.retrievedDate],
    ['Exported Date', exportData.metadata.exportedDate],
    ['Exported By', exportData.metadata.exportedBy],
    ['Audit Trail ID', exportData.metadata.auditTrailId],
  ]
  
  if (exportData.fullText) {
    rows.push(['Full Text', exportData.fullText.replace(/"/g, '""')])
  }
  
  return rows.map(row => row.map(cell => `"${cell}"`).join(',')).join('\n')
}

function escapeHtml(text: string): string {
  const div = document.createElement('div')
  div.textContent = text
  return div.innerHTML
}

export async function downloadExport(
  exportData: CourtDefensibleExport,
  options: ExportOptions,
  filename: string
): Promise<void> {
  let content: string
  let mimeType: string
  
  switch (options.format) {
    case 'txt':
      content = formatExportAsText(exportData, options)
      mimeType = 'text/plain'
      break
    case 'md':
      content = formatExportAsMarkdown(exportData, options)
      mimeType = 'text/markdown'
      break
    case 'html':
      content = formatExportAsHTML(exportData, options)
      mimeType = 'text/html'
      break
    case 'json':
      content = formatExportAsJSON(exportData)
      mimeType = 'application/json'
      break
    case 'csv':
      content = formatExportAsCSV(exportData)
      mimeType = 'text/csv'
      break
    case 'bibtex':
      const citation = generateBibTeX(exportData.metadata as unknown as CitationMetadata)
      content = citation
      mimeType = 'application/x-bibtex'
      break
    default:
      content = formatExportAsText(exportData, options)
      mimeType = 'text/plain'
  }
  
  const blob = new Blob([content], { type: mimeType })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = filename
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
}

export function getDefaultExportOptions(): ExportOptions {
  return {
    format: 'txt',
    citationStyle: 'bluebook',
    includeFullText: true,
    includeMetadata: true,
    includeDisclaimers: true,
    includeAuditTrail: true,
    includeVerificationInfo: true,
    timestamp: true,
  }
}
